<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style>
			/*
			 我们的页面设计出来是为了兼容不同的移动设备
			 不同的移动设备的分辨率不一样
			 因此，需要根据移动设备的分辨率自动调节容器的宽度
			 	比如：
			 		最小宽度：768px，container宽度为 750px
			 		最小宽度：992px，container宽度为 970px
			 * */
			
			@media screen and (min-width:360px) and (max-width:374px) and (orientation:portrait) {
			    html { font-size: 70.3%; }
			}
			@media screen and (min-width:375px) and (max-width:383px) and (orientation:portrait) {
			    html { font-size: 73.24%; }
			}
			@media screen and (min-width:384px) and (max-width:399px) and (orientation:portrait) {
			    html { font-size: 75.0%; }
			}
			@media screen and (min-width:400px) and (max-width:413px) and (orientation:portrait) {
			    html { font-size: 78.125%; }
			}
			@media screen and (min-width:414px) and (max-width:431px) and (orientation:portrait){
			    html { font-size: 80.86%; }
			}
			@media screen and (min-width:432px) and (max-width:479px) and (orientation:portrait){
			    html { font-size: 84.375%; }
			}
			html {font-size: 62.5%; /*100 ÷ 16 × 100% = 625%*/}
			.container{
				font-size: 2rem;
			}
			h2{
				font-size: 4rem;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h2>为什么要使用rem</h2>
			<p>
				之前有些适配做法，是通过js动态计算viewport的缩放值（initial-scale）。

				例如以屏幕320像素为基准，设置1，那屏幕375像素就是375/320=1.18以此类推。
				
				但直接这样强制页面缩放过于粗暴，会导致页面图片文字失真模糊。
				
				Px是相对固定单位，字号大小直接被定死，所以用户无法根据自己设置的浏览器字号而缩放，em和rem虽然都是相对单位，但em是相对于它的父元素的font-size，页面层级越深，em的换算就越复杂，而rem是直接相对于根元素，这就避开了很多层级关系。移动端新型浏览器对rem的兼容很好，可以放心使用。
			</p>
		</div>
	</body>
</html>
